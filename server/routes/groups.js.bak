// General libraries
let _ = require('underscore');
let db2 = require('../database').db2;
let db2 = require('../database').db2;
let ObjectId = require('mongodb').ObjectID;
let Promise = require('bluebird');
let Chance = require('chance');
let Color = require('color');

// Own references
let C = require('../../shared/constants').C;
let cfg = require('../../shared/config').cfg;
let ratings = require('./ratings');
let topics = require('./topics');
let pads = require('./pads');
let mail = require('../mail');
let utils = require('../utils');

function getGroupMembersAsync(groupId) {
	return db2.group_relations.find({'groupId': groupId});
}

function calculateNumberOfGroups(numTopicParticipants) {
	
	// TODO throw error if group size is smaller than 3
	//if(cfg.GROUP_SIZE < 3)
	
	let numGroups = Math.ceil(numTopicParticipants/cfg.GROUP_SIZE); // round up to next integer
	console.log('number of groups: ', numGroups);
	
	return numGroups;
}

function assignParticipantsToGroups(participants) {
	// Shuffle topic participants
	_.shuffle(participants);
	
	// Compute number of groups
	let numGroups = calculateNumberOfGroups(_.size(participants));
	
	// Initialize groups (as empty array)
	let groups = new Array(numGroups);
	for(let i=0; i<numGroups; ++i) {
		groups[i] = [];
	}
    
	// Push topic participants into groups
	_.each(participants, function(participant) {
		// Find first smallest group
		let group = _.min(groups, group => _.size(group));
		group.push(participant);
	});
    
	// TODO log with logging library
	// Log group member distribution
	let counts = _.countBy(groups, group => _.size(group));
	console.log('groups filled: ' + JSON.stringify(counts));
	
	return groups;
}

/*
 * @desc: Store group, group pad and members in database
 *        Called from initial creation and remix
 * @params:
 *    groupId: id of the new group
 *    topicId: id of the related topic
 *    padId: id of the related pad
 *    groupRelations: relations of group (user, previous pad, previous group)
 *    nextDeadline: deadline of the next stage (not the old one)
 *    level: new level (old level +1)
 */
function storeGroupAsync(groupId, topicId, padId, groupRelations, nextDeadline, level) {
	let chatRoomId = ObjectId();
	let forumId = ObjectId();
	
	// Create group itself
	let group = { '_id': groupId, 'topicId': topicId, 'chatRoomId': chatRoomId, 'forumId': forumId, 'level': level };
	let createGroup_promise = db2.groups.insert(group);
	
	// Create group pad
	let pad = { '_id': padId, 'topicId': topicId, 'groupId': groupId, 'expiration': nextDeadline };
	let createPadProposal_promise = pads.createPadAsync(pad, 'group');
	
	// Create forum for group
	let forum = { '_id': forumId, 'groupId': groupId };
	let createForum_promise = db2.forums.insertAsync(forum);
	
	// Insert group members to database
	let insertMembers_promise =
	db2.collection('group_relations').insert(
		_.map(groupRelations, function(rel) {
			let prevGroupId = _.isUndefined(rel.prevGroupId) ? null : rel.prevGroupId;
			return { 'groupId': groupId, 'userId': rel.userId, 'prevGroupId': prevGroupId, 'prevPadId': rel.prevPadId, 'lastActivity': -1 };
		})
	);
	
	return Promise.join(createPadProposal_promise, createGroup_promise, createForum_promise, insertMembers_promise);
}

/**
 * @desc: Check if specific proposal is valid, return true or false
 * @param:
 *     html: text of the proposal as html
 */
function isProposalValid(html) {
	// Valid if number of words in html is greater than configured threshold
	return utils.countHtmlWords(html) >= cfg.MIN_WORDS_PROPOSAL;
}

/**
 * @desc: initial creation of groups after proposal stage
 *        - check if user proposals are valid (filter participants)
 *        - randomly assign participants to groups
 */
exports.createGroupsAsync = function(topic) {
	let topicId = topic._id;
	
	let validParticipants_promise = db2.pads_proposal
		.find({ 'topicId': topicId })
		.map(function(pad) {
			// Get html of doc and add valid status to pad object
			return pads.getPadHTMLAsync('proposal', pad.docId).then(function(html) {
				return _.extend(pad, {'valid': isProposalValid(html)});
			});
		}).then(function(pads) {
			// Filter by valid status and return id's of users
			return _.pluck(_.filter(pads, pad => pad.valid), 'ownerId');
	});
	
	let storeValidParticipantsPromise = validParticipants_promise.then(function(validParticipants) {
		console.log(validParticipants);
		return db2.topics.update(
			{ '_id': topic._id },
			{ $set: { 'validParticipants': _.size(validParticipants) } });
	});
	
	// Create group and notify members
	let createGroupsPromise = validParticipants_promise.then(function(validParticipants) {
		return assignParticipantsToGroups(validParticipants);
	}).map(function(group_members) {
		// Create new group id
		let topicId = topic._id;
		let groupId = ObjectId();
		
		// TODO Notifications
		// Send mail to notify new group members
		let send_mail_promise = db2.users
			.find({'_id': { $in: group_members }}, {'email': true})
			.then(function(users) {
				mail.sendMailMulti(users,
					'EMAIL_CONSENSUS_START_SUBJECT', [topic.name],
					'EMAIL_CONSENSUS_START_MESSAGE', [topic.name, groupId.toString(), cfg.PRIVATE.BASE_URL]);
		});
		
		// Get group relations (previous pad ids and member ids)
		// Note: previous group id is not possible here, since initially there is no previous group
		let groupRelations_promise = db2.pads_proposal
			.find({ 'topicId': topicId, 'ownerId': {$in: group_members} }, {'_id': true, 'ownerId': true}).toArrayAsync()
			.map(function(rawGroupRelation) {
				return { 'prevPadId': rawGroupRelation._id, 'userId': rawGroupRelation.ownerId };
			});
			
			
		
		// Store group in database
		let padId = ObjectId();
		let nextDeadline = topic.nextDeadline;
		let store_group_promise = groupRelations_promise.then(function(groupRelations) {
			console.log('groupRelations', groupRelations);
			return storeGroupAsync(groupId, topicId, padId, groupRelations, nextDeadline, 0);
		});
		
		// Join promises and return group members
		return Promise
			.join(send_mail_promise, store_group_promise)
			.return(group_members);
	});
    
	return Promise.join(createGroupsPromise, storeValidParticipantsPromise).get(0);
};

function getGroupsOfSpecificLevelAsync(topicId, level) {
    return db2.collection('groups').find({ 'topicId': topicId, 'level': level }).toArrayAsync();
}
exports.getGroupsOfSpecificLevelAsync = getGroupsOfSpecificLevelAsync;

function getValidGroupsOfSpecificLevelAsync(topicId, level) {
	return getGroupsOfSpecificLevelAsync(topicId, level).filter(async function(group) {
		const proposal = await db2.pads_group.findOne({'groupId': group._id})
		
		// Get HTML from document
		proposal.body = await pads.getPadHTMLAsync('group', proposal.docId);
		
		console.log('html', proposal.body);
		console.log('isValid', isProposalValid(proposal.body));
		// Check if proposal is valid
		return isProposalValid(proposal.body);
	}).then(function(groups) {
		console.log('groups', groups);
		// If no valid proposal exists: reject, otherwise return all valid groups
		if(_.isEmpty(groups))
			return Promise.reject({reason: 'REJECTED_NO_VALID_GROUP_PROPOSAL'});
		else
			return Promise.resolve(groups);
	});
}

/**
 * @desc: Create groups after level is finished
 *        - Check if group proposals are valid (filter groups)
 *        - Find group leader (with highest rating)
 *        - Randomly assign participants to new groups
 *        - Store previous groups in new group
 */
exports.remixGroupsAsync = function(topic) {
    let topicId = topic._id;
    
    // Get groups with highest level
    let groups_promise = getValidGroupsOfSpecificLevelAsync(topicId, topic.level);
    
	// Get group leaders
	let leaders_promise = groups_promise.map(function(group_in) {
		let groupId = group_in._id;
		
		const leader = ratings.getGroupLeaderAsync(groupId);
		if(!!leader) {
			return Promise.resolve(leader);
		}
		
		// If group leader is undefined, pick one randomly
		const members = getGroupMembersAsync(groupId);
		return Promise.resolve(_.sample(members).userId);
	});
    
	return Promise.join(groups_promise, leaders_promise).spread(async function(groups, leaders) {
		/*
		 * If there is only ONE group in the current topic level, then the topic is finished/passed
		 */
		if(_.size(groups) == 1) {
			// Send mail to ALL initial participants and notifiy about finished topic
			// finally return next stage
			const groups = await db2.groups.find({ 'topicId': topic._id, 'level': 0 });
			const participants = await db2.group_relations.find({'groupId': { $in: _.pluck(groups, '_id') }}, {'userId': true});
			
			const users = await db2.users
				.find({'_id': { $in: _.pluck(participants, 'userId') }}, {'email': true});
			await mail.sendMailMulti(users,
				'EMAIL_TOPIC_PASSED_SUBJECT', [topic.name],
				'EMAIL_TOPIC_PASSED_MESSAGE', [topic.name, topic._id, cfg.PRIVATE.BASE_URL]
			);

			return Promise.resolve({'nextStage': C.STAGE_PASSED});
		}
       
      /* 
       * If there is more than one group in the current topic level, prepare next level
       */
		// Assign members to groups
		let groupsMemberIds_promise = assignParticipantsToGroups(leaders);
		
		// Insert all groups into database
		let nextLevel = topic.level+1;
		return Promise.map(groupsMemberIds_promise, async function(groupMemberIds) {
         // Get group relations (prevPadIds, prevGroupIds and member ids)
			const prevGroups = await db2.group_relations
				.find({ 'groupId': {$in: _.pluck(groups, '_id')}, 'userId': {$in: groupMemberIds} }, { 'groupId': true, 'userId': true });

			// prevGroupIds and member ids are already given, prevPadIds need to be found (= current group pads)
			const prevGroupIds = _.pluck(prevGroups, 'groupId');
			const prevPads = await db2.pads_group.find({'groupId': {$in: prevGroupIds}}, {'_id': true, 'groupId': true});
			
			console.log('BEFORE', prevGroups, prevPads);
			// Bring both information in form
			prevGroups = _.map(prevGroups, g => ({ 'prevGroupId': g.groupId, 'userId': g.userId }));
			prevPads = _.map(prevPads, p => ({ 'prevGroupId': p.groupId, 'prevPadId': p._id }));
			console.log('AFTER', prevGroups, prevPads);
			
			return utils.mergeCollections(prevGroups, prevPads, 'prevGroupId');
		});
         
         // Initalize group variables
         let groupId = ObjectId();
         let topicId = topic._id;
         let padId = ObjectId();
         let prevDeadline = topic.nextDeadline;
         let nextDeadline = topics.calculateDeadline(C.STAGE_CONSENSUS, prevDeadline);
         
         // Store group in database
         const groupRelations = await groupRelations_promise;
         await storeGroupAsync(groupId, topicId, padId, groupRelations, nextDeadline, nextLevel);

        // Send mail to notify level change
	    const users = await db2.users.find({'_id': {$in: groupMemberIds}}, {'email': true});
		mail.sendMailMulti(users,
			'EMAIL_LEVEL_CHANGE_SUBJECT', [topic.name],
			'EMAIL_LEVEL_CHANGE_MESSAGE', [topic.name, groupId.toString(), cfg.PRIVATE.BASE_URL]);

		return Promise.resolve({'nextStage': C.STAGE_CONSENSUS});  // We stay in consensus stage
	}).catch(utils.isOwnError,function(error) {
		return {
			'nextStage': C.STAGE_REJECTED,
			'rejectedReason': error.reason
		};
	});
};

/* @desc: Gets group editor information, necessary information are:
 *        - groupId, topicId, docId (can be found in pad)
 *        - level, name, nextDeadline (can be found in topic)
 *        - chatRoomId (can be found in group)
 *        - isLastGroup
 *        - members (includes: color, name, userId, ratingIntegration, ratingKnowledge)
 */
exports.query = function(req, res) {
	let padId = ObjectId(req.params.id);
	let userId = ObjectId(req.user._id);
	
	// Get docId, groupId and topicId from group pad
	let pad_promise = db2.collection('pads_group').findOne({'_id': padId});
	
	// Everything else depends on pad
	pad_promise.then(function(pad) {
		// Define some variables for simpler and more intuitie use
		let groupId = pad.groupId;
		let topicId = pad.topicId;
		
		/*
		 * Simple stuff
		 */
		
		// Get topic name
		let topic = await db2.collection('topics').findOne({'_id': topicId}, {'name': true});
		
		// Get chatRoomId from group
		let isLastGroup = await db2.collection('groups').findOne({'_id': pad.groupId});
		
		// Count number of groups in current level to obtain if we are in last group (last level)
		//let isLastGroup = group_promise.then(function(currentGroup) {
			const currentGroup = 
			const numGroupsInCurrentLevel = await db2.collection('groups').count({ 'topicId': currentGroup.topicId, 'level': currentGroup.level });
			
			const isLastGroup = (numGroupsInCurrentLevel == 1) ? true : false;
		//});
		/*let isLastGroup_promise = group_promise.then(function(currentGroup) {
			return db2.collection('groups').countAsync({ 'topicId': currentGroup.topicId, 'level': currentGroup.level })
				.then(function(numGroupsInCurrentLevel) {
					return (numGroupsInCurrentLevel == 1) ? true : false;
			});
		});
		
		/*
		 * Group Members
		 */
		
		// Get group members
		let groupRelations_promise = getGroupMembersAsync(groupId);
		
		// Get number of group members
		let num_group_members_promise = groupRelations_promise.then(function(group_members) {
			return _.size(group_members);
		});
		
		// Generate group specific color_offset
		let chance = new Chance(groupId.toString());
		let offset = chance.integer({min: 0, max: 360});
		
		// Get previous pads
		let prevPads_promise = Promise.join(group_promise, groupRelations_promise).spread(function(group, groupRelations) {
			let prevPadIds = _.pluck(groupRelations, 'prevPadId');
			if (group.level == 0) {
				return db2.collection('pads_proposal')
					.find({ '_id': {$in: prevPadIds} }, { 'ownerId': true, 'docId': true }).toArrayAsync();
			} else {
				return db2.collection('pads_group')
					.find({ '_id': {$in: prevPadIds} }, { 'groupId': true, 'docId': true }).toArrayAsync();
			}
		});
		
		// Get group members
		let groupMembersDetails_promise = groupRelations_promise.map(function(relation, index) {
			
			// Generate member color
			let memberColor_promise = num_group_members_promise.then(function(numMembers) {
				let hue = offset + index*(360/numMembers);
				return Promise.resolve(Color({h: hue, s: 20, v: 100}).hex());
			});
         
         // Get proposal html
         let prevPadHtml_promise = Promise.join(group_promise, prevPads_promise).spread(function(group, prevPads) {
         	if (group.level == 0) {
	         	let prevUserPad = utils.findWhereObjectId(prevPads, {'ownerId': relation.userId});
	         	return pads.getPadHTMLAsync('proposal', prevUserPad.docId);
         	} else {
         		let prevGroupPad = utils.findWhereObjectId(prevPads, {'groupId': relation.prevGroupId});
         		return pads.getPadHTMLAsync('group', prevGroupPad.docId);
         	}
         });
			
			// Get member rating
			let memberRatingKnowledge_promise = ratings.getMemberRatingAsync(relation.userId, groupId, userId, C.RATING_KNOWLEDGE);
			let memberRatingIntegration_promise = ratings.getMemberRatingAsync(relation.userId, groupId, userId, C.RATING_INTEGRATION);
         
         return Promise.props({
         	'userId': relation.userId,
				'name': chance.first(),
				'color': memberColor_promise,
				'prevPadHtml': prevPadHtml_promise,
				'ratingKnowledge': memberRatingKnowledge_promise,
				'ratingIntegration': memberRatingIntegration_promise
         });
		});
		
		// Finally, set lastActivity for the member querying the group
		let lastActivity_promise = db2.collection('group_relations')
			.updateAsync({ 'grouId': groupId, 'userId': userId }, { $set: {'lastActivity': Date.now()} });
		
		// Collect all information and return
		return Promise.join(topic_promise, group_promise, isLastGroup_promise, groupMembersDetails_promise, lastActivity_promise)
			.spread(function(topic, group, isLastGroup, group_members) {
				return {
					'groupId': groupId,
					'topicId': topicId,
					'docId': pad.docId,
					'level': group.level,
					'title': topic.name,
					'deadline': pad.expiration,
					'chatRoomId': group.chatRoomId,
					'forumId': group.forumId,
					'isLastGroup': isLastGroup,
					'members': group_members
				};
		});
	}).then(res.json.bind(res));
};
